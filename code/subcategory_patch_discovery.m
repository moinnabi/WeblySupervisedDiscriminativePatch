%function [I bbox gtbox relpos_patch deform_param models models_all ps_detect sp_consist_mat sp_consis_score img_part] = demo_subcategory(VOCopts, ps, numPatches,coverage_thershold,dir_class,dir_neg,finalresdir,comp)
function [patch_per_comp] = subcategory_patch_discovery(VOCopts, ps, numPatches,dir_class,dir_neg,voc_ng_train,category,component,top_num_part,vis_type)

%by Moin
 
%Select random "patches" on each Positive image (belongs to this subcategory)
disp('auto_get_part_fast');
[I bbox gtbox] = auto_get_part_fast(ps, numPatches,0.25,0.75);

%Find relative position and Deformation Parameter for each Query patch
for i = 1:numPatches
    root_bbox = gtbox{i}; part_bbox = bbox{i}(1:4);
    relpos_patch_normal{i} = relative_position(root_bbox,part_bbox,1); %1 means normalized (regionlet)
end

%Train Examplar-LDA for each patch (Query)
addpath(genpath('bcp_release/'));
currentFolder = pwd;
VOCopts.localdir = [currentFolder(1:end-5),'/data/bcp_elda/'];
disp('orig_train_elda');
models = orig_train_elda(VOCopts, I, bbox, dir_class, dir_neg , 0, 1);
for mod = 1:length(models)
    models_all{mod} = models{1,mod}.model;
end

%Compute Deformation Parameter for each Query patch
for i = 1:numPatches
    mdl = models_all{i};
    im = imread(I{i});
     deform_param_patch{i} = deform_param(im,mdl,1); %MISSING: Now is fixed for all!!! [0.3 0.3]
end

%Run the fixed position detector on all Positive images and find Pos_score
disp('doing part inference on positive samples in Subcategory');
tic
parfor i = 1:length(ps)
    disp([int2str(i),'/',int2str(length(ps))])
    im_current = imread(ps{1,i}.I);
    root_bbox = ps{1,i}.bbox;

    bbox_current = inverse_relative_position_all(root_bbox,relpos_patch_normal,1);
    [detection_loc , ap_score , sp_score ] = part_inference_inbox(im_current, models_all, bbox_current);
%    [detection_loc , ap_score , sp_score] = part_inference_inbox_Qdeformation(im_current, models_all, bbox_current,root_bbox,deform_param_patch,1);    % FOR Spatial quadratice distance
     ps_detect{i}.sp_scores = sp_score;
     ps_detect{i}.ap_scores = ap_score;
    %ps_detect{i}.scores = num2cell(horzcat(ap_score{:}).*horzcat(sp_score{:}));
     ps_detect{i}.patches = detection_loc;
end
toc

%Run the fixed position detector on negative VOC train set (Detect inside the bbox generated by santosh's model)
tic
disp('Patch detection on VOC negative test');
model_tmp = load('../data/ngram_models/horse/kmeans_6/mountain_horse_super/mountain_horse_super_parts.mat','models'); %% CHANGE!!!
model_santosh = model_tmp.models{component};
thresh = model_santosh.thresh;
[ng_detect] = run_patches_inside_santosh_on_negative(model_santosh,models_all,voc_ng_train,relpos_patch_normal,thresh);
%[ng_detect] = run_patches_inside_santosh_on_negative_Qdeformation(model_santosh,models_all,voc_ng_train,relpos_patch_normal,thresh,deform_param_patch);    % FOR Spatial quadratice distance
%[ng_detect] = run_patches_inside_wholeimage_on_negative(models_all,voc_ng_train);
toc

disp('Computing Representation measure based on SP/AP consistancy');
% get detected patches and computer matrix of image by patch showing representation measure over the normalized valuse of SP and AP
%[sp_score_all_norm,ap_score_all_norm,rep_score] = compute_rep_score(ps_detect,1,1,5);
[~,~,rep_score] = compute_rep_score(ps_detect,1,1,5);

disp('Computing Descriminative measure inside the subcategory');
% Use PRECISION as the measure of desciminativeness
[ps_score,ng_score,disc_score] = compute_disc_score(ps_detect,ng_detect,1,1,0.25);

%good patch selection
disp('Patch selection for each subcategory');
[patch_selected, total_score] = subcategory_patch_selection(rep_score,disc_score,1,1,top_num_part);


%% Retraining the Patch Models Using Linear SVM / Latent-SVM / Latent-LDA
sel_ind = find(patch_selected);

model_retrained = models_all;
for i = 1:length(sel_ind)
    disp(['Re-training ', int2str(i),' / ',int2str(length(sel_ind))]);
    patch_ind = sel_ind(i);
%    model_retrained{patch_ind} = retrain_patch_svm(ps,voc_ng_train,ps_detect,ng_detect,patch_ind)
%    model_retrained{patch_ind} = retrain_patch_lsvm(ps,voc_ng_train,ps_detect,ng_detect,patch_ind,80,0);
    model_retrained{patch_ind} = retrain_patch_llda(ps,ps_detect,ng_detect,patch_ind,50);
end


%% selected models

sel_ind = find(patch_selected);
model_selected = [];
relpos_patch_normal_selected = [];
deform_param_patch_selected = [];
for i = 1:length(sel_ind)
    model_selected{i} = model_retrained{sel_ind(i)};
    relpos_patch_normal_selected{i} = relpos_patch_normal{sel_ind(i)};
    deform_param_patch_selected{i} = deform_param_patch{sel_ind(i)};
end


%% Save parameters is an struct
patch_per_comp.I = I;
patch_per_comp.bbox = bbox;
patch_per_comp.gtbox = gtbox;
patch_per_comp.relpos_patch_normal = relpos_patch_normal;
patch_per_comp.deform_param_patch = deform_param_patch;
patch_per_comp.models = models;
patch_per_comp.models_all =models_all;
patch_per_comp.models_selected = model_selected;
patch_per_comp.relpos_patch_normal_selected = relpos_patch_normal_selected;
patch_per_comp.deform_param_patch_selected = deform_param_patch_selected;
%
patch_per_comp.ps = ps;            
patch_per_comp.ps_detect = ps_detect;
patch_per_comp.ng_detect = ng_detect;
patch_per_comp.ps_score = ps_score;
patch_per_comp.ng_score = ng_score;
%
patch_per_comp.rep_score = rep_score;
patch_per_comp.disc_score = disc_score;
patch_per_comp.patch_selected = patch_selected;
patch_per_comp.total_score = total_score;

%% Visualization code
% type 1 means: just selected patch
% type 2 means: selected patch with the mined examples in pos/neg set
type = find(vis_type);
if ~isempty(type)
    if length(type) == 1
        type_i = type;
        visualize_all(ps,patch_per_comp,voc_ng_train,type_i);
    else
        for type_i = 1:length(type)
            visualize_all(ps,patch_per_comp,voc_ng_train,type_i);
        end
    end
end